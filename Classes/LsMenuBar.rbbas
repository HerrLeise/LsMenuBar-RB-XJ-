#tag ClassProtected Class LsMenuBarInherits Canvas	#tag Event		Sub Deactivate()		  MouseInside = False		  self.mHelptag = "[#KILL]"		End Sub	#tag EndEvent	#tag Event		Function KeyDown(Key As String) As Boolean		  return true		End Function	#tag EndEvent	#tag Event		Function MouseDown(X As Integer, Y As Integer) As Boolean		  MouseX = X		  MouseY = Y		  		  self.mHelpTag = "[#KILL]"		  		  if kModuleVersion>1 Then //only provide feature in Version 2		    if (IsContextualClick = True) and (BehaveAsToolBar = True) Then		      		      OpenContextMenu		      		      return false		      		    End If		  End If		  		  'ConsoleLog("REDRAW - MouseDown - " + Str(Microseconds))		  		  self.Invalidate()		  		  Dim tP As Picture = New Picture(1,1,32)		  tp.Graphics.TextFont = me.TextFont		  tp.Graphics.TextSize = me.TextSize		  tp.Graphics.TextUnit = FontUnits.Pixel		  		  DIm i,n As Integer		  Dim w,h As Integer		  h = self.height		  Dim offset As Integer = 0		  n = BaseMenu.Ubound		  If n>-1 Then		    		    		    		    For i=0 to n		      		      Dim mW As Integer = basemenu(i).MenuPic.Width		      Dim mSelected As Boolean = False		      		      If (X > (self.left + offset)) and (X< (self.left + offset + mW)) Then		        if IsContextualClick = False Then		          if (BaseMenu(i).isVisible) and (BaseMenu(i).isEnabled) Then		            BaseMenu(i).DrawMenuItem(true,false)		            selectedMenuItem = BaseMenu(i)		            		            'ConsoleLog("REDRAW - MouseDown_BaseMenu - " + Str(Microseconds))		            self.Invalidate()		            		            RaiseEvent HitMenuItem(selectedMenuItem)		            		            OpenHitMenu(selectedMenuItem,offset)		            		          End If		        End If		        Exit For i		        		        		      End If		      		      offset = offset + mW		      		    Next		    		  End If		  		  		  If ((x>=overflowMX)and(x<=overFlowMX+overFlowMWidth)) and ((y>=overFlowMY)and(y<=overFlowMY+self.height)) Then		    		    'Self.refresh()		    self.Invalidate()		    		    if IsContextualClick = False Then		      		      mOVMenu.DrawMenuItem(true,false)		      		      selectedMenuItem = mOVMenu		      		      		      'ConsoleLog("REDRAW - MouseDown_Overflow - " + Str(Microseconds))		      self.Invalidate()		      		      OpenHitMenu(mOVMenu,overFlowMX)		    End If		    'HitMenuItem(selectedMenuItem)		  Else		    selectedMenuItem = nil		  End If		  		  		  		  		  		  return true		End Function	#tag EndEvent	#tag Event		Sub MouseEnter()		  self.Invalidate()		  		  MouseInside = True		  'ConsoleLog("REDRAW - MouseEnter - " + Str(Microseconds))		End Sub	#tag EndEvent	#tag Event		Sub MouseExit()		  'self.Invalidate(true)		  		  		  self.mHelptag = "[#KILL]"		  		  		  DIm i,n As Integer		  Dim w,h As Integer		  h = self.height		  Dim offset As Integer = 0		  		  if BehaveAsToolBar Then offset = 4		  		  n = BaseMenu.Ubound		  If n>-1 Then		    		    For i=0 to n		      BaseMenu(i).DrawMenuItem(false,false)		    Next		    		  End If		  		  		  		  'ConsoleLog("REDRAW - MouseExit - " + Str(Microseconds))		  self.Refresh()		  		  if BehaveAsToolBar Then		    MouseInside = False		  End If		End Sub	#tag EndEvent	#tag Event		Sub MouseMove(X As Integer, Y As Integer)		  MouseX = X		  MouseY = Y		  		  If MouseInside = False Then MouseInside = True		  		  'if (BehaveAsToolBar and (ClickAction = True)) Then return		  		  'Dim mI As LsMenuItem = GetMenuItemFromXY(X,Y,false,true)		  		  'self.Refresh		  		  'ConsoleLog("REDRAW - MouseMove - " + Str(Microseconds))		  		  if isActive Then self.Invalidate()		End Sub	#tag EndEvent	#tag Event		Sub MouseUp(X As Integer, Y As Integer)		  //Click		  		  if (BehaveAsToolBar and (ClickAction = True)) Then return		  		  'selectedMenuItem = nil		  		  		  'ConsoleLog("REDRAW - MouseMove - " + Str(Microseconds))		  		  self.Invalidate()		  		End Sub	#tag EndEvent	#tag Event		Sub Open()		  		  		  self.EraseBackground = False		  self.DoubleBuffer = True		  		  		  		  		  //Setup ContextMenu		  contextMenu = New MenuItem		  contextmenu.append(New MenuItem("Symbolleiste anpassen"))		  		  //------------------		  		  		  		  		  		  MouseDog = new Timer		  MouseDog.period = 150		  MouseDog.Mode = Timer.ModeMultiple		  		  		  AddHandler MouseDog.Action, WeakAddressOf MouseDogAction		  		  		  'KeyDog = new Timer		  'KeyDog.period = 150		  'KeyDog.Mode = Timer.ModeMultiple		  '		  'AddHandler KeyDog.Action, WeakAddressOf KeyDogAction		  		  		  useMBS_MouseFunctions = False		  		  MouseInside = False		  		  		  		  		  		End Sub	#tag EndEvent	#tag Event		Sub Paint(g As Graphics, areas() As REALbasic.Rect)		  if isActive Then		    		    'if (BehaveAsToolBar and (ClickAction = True)) Then return		    		    		    if g<>Nil Then		      		      lastBufPic = New Picture(self.Width,self.Height,32)		      		      lastBufPic.Graphics.TextFont = TextFont		      lastBufPic.Graphics.TextSize = TextSize		      lastBufPic.Graphics.TextUnit = FontUnits.Pixel		      		      		      Redraw(lastBufPic.Graphics)		      		      g.DrawPicture(lastBufPic,0,0)		      		    End If		    		    		  Else		    if g<>Nil Then		      if lastBufPic<>Nil Then		        		        if lastBufPic.width = self.Width and lastBufPic.Height = self.Height Then		          		          g.DrawPicture(lastBufPic,0,0)		          		        Else		          		          lastBufPic = New Picture(self.Width,self.Height,32)		          		          lastBufPic.Graphics.TextFont = TextFont		          lastBufPic.Graphics.TextSize = TextSize		          lastBufPic.Graphics.TextUnit = FontUnits.Pixel		          		          		          Redraw(lastBufPic.Graphics)		          		          g.DrawPicture(lastBufPic,0,0)		          		        End If		        		      End If		    End If		  end if		End Sub	#tag EndEvent	#tag Method, Flags = &h0		Sub AddBaseMenu(menu As LsMenuItem)		  //When creating an LsMenuItem you need to provide the MenuName and a uID		  		  		  		  menu.MenuBarHeight = me.height		  menu.TextColor = TextColor		  menu.TextSize = TextSize		  menu.TextFont = TextFont		  menu.TextHighlightColor = TextHighlightColor		  menu.ItemHighlightColor = ItemHighlightColor		  menu.FillColor = FillColor		  menu.ItemHoverColor = ItemHoverColor		  menu.ToolBarBorderColor = ToolBarItemBorderColor		  menu.Icon = menu.ToolbarIcon		  		  menu.DrawMenuItem(false,false,true)		  		  BaseMenu.Append menu		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub AddSubMenu(topLevelMenuName As String, baseMenuName As String, newItem As MenuItem)		  DIm i,n As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If BaseMenu(i).MenuName = topLevelMenuName Then		        if BaseMenu(i).baseMenu<>Nil Then		          Dim bi,bn As Integer		          bn = BaseMenu(i).baseMenu.count		          if bn>0 Then		            For bi=1 to bn		              If BaseMenu(i).baseMenu.Item(bi-1).Text = baseMenuName Then		                BaseMenu(i).baseMenu.Item(bi-1).Append(newItem)		                mForceRedraw = True		                Exit For i		              End If		            Next		          End If		          		        End If		      End If		    Next		  End If		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub AddSubToolMenu(baseMenuName As String, newItem As MenuItem)		  DIm i,n As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If BaseMenu(i).MenuName = baseMenuName Then		        		        		        BaseMenu(i).AddItem(newItem)		        Exit For i		        		        		      End If		    Next		  End If		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ClearSubMenu(topLevelMenuName As String, baseMenuName As String)		  DIm i,n As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If BaseMenu(i).MenuName = topLevelMenuName Then		        if BaseMenu(i).baseMenu<>Nil Then		          Dim bi,bn As Integer		          bn = BaseMenu(i).baseMenu.count		          if bn>0 Then		            For bi=1 to bn		              If BaseMenu(i).baseMenu.Item(bi-1).Text = baseMenuName Then		                Dim si,sn As Integer		                sn = BaseMenu(i).baseMenu.Item(bi-1).Count - 1		                If sn>-1 Then		                  For si=sn downto 0		                    'BaseMenu(i).baseMenu.Item(bi-1).Close()		                    'BaseMenu(i).baseMenu.Item(bi-1)		                    if BaseMenu(i).baseMenu.Item(bi-1) isa LsMenuItem Then		                      LsMenuItem(BaseMenu(i).baseMenu.Item(bi-1)).ClearCaches()		                    end if		                    BaseMenu(i).baseMenu.Item(bi-1).Remove(si)'.Close()		                    'sn = sn - 1		                  Next		                  mForceRedraw = True		                  Exit For i		                End If		                'BaseMenu(i).baseMenu.Item(bi-1).Close '. = New MenuItem()		                		              End If		            Next		          End If		          		        End If		      End If		    Next		  End If		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ClearSubToolMenu(baseMenuName As String)		  DIm i,n As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If BaseMenu(i).MenuName = baseMenuName Then		        		        BaseMenu(i).DeleteMenuItems()		        mForceRedraw = True		        Exit For i		        		      End If		    Next		  End If		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Cocoa_LeftClickMouse()		  //Code by: Jason K		  // https://forum.xojo.com/12285-move-mouse-cursor-and-click-by-code-for-mac		  // 25 May 2014		  		  #if targetmacos		    #if TargetCocoa		      		      		      //declare necessary functions, etc		      Declare sub CFRelease lib "Cocoa" ( ref as ptr )		      		      'CGEventRef CGEventCreate (		      'CGEventSourceRef source		      ');		      Declare Function CGEventCreate lib "ApplicationServices" (CGEventSourceRef as ptr) as Ptr		      		      'CGPoint CGEventGetLocation (		      'CGEventRef event		      ');		      Declare Function CGEventGetLocation lib "ApplicationServices" (CGEventRef as Ptr) as CGPoint		      		      'CGEventRef CGEventCreateMouseEvent (		      'CGEventSourceRef source,		      'CGEventType mouseType,		      'CGPoint mouseCursorPosition,		      'CGMouseButton mouseButton		      ');		      		      '/* mouse events */		      '		      '#define NX_LMOUSEDOWN         1    /* left mouse-down event */		      '#define NX_LMOUSEUP               2    /* left mouse-up event */		      '#define NX_RMOUSEDOWN         3    /* right mouse-down event */		      '#define NX_RMOUSEUP               4    /* right mouse-up event */		      '#define NX_MOUSEMOVED          5    /* mouse-moved event */		      '#define NX_LMOUSEDRAGGED     6    /* left mouse-dragged event */		      '#define NX_RMOUSEDRAGGED     7    /* right mouse-dragged event */		      '#define NX_MOUSEENTERED        8    /* mouse-entered event */		      '#define NX_MOUSEEXITED           9    /* mouse-exited event */		      Declare Function CGEventCreateMouseEvent lib "ApplicationServices" (CGEventSourceRef as ptr, _		      CGEventType as UInt32, position as CGPoint, CGMouseButton as UInt32) as ptr		      //////////		      'using the other constants above in place of these allows for right clicking, simulating mouse moved		      'events, etc		      //////////		      const kCGEventLeftMouseDown = 1		      const kCGEventLeftMouseUp = 2		      		      'void CGEventPost (		      'CGEventTapLocation tap,		      'CGEventRef event		      ');		      Declare sub CGEventPost lib "ApplicationServices" (CGEventTapLocation as UInt32, CGEventRef as ptr)		      const tapLocation = 0		      		      'CGEventSourceRef CGEventSourceCreate (		      'CGEventSourceStateID sourceState		      ');		      Declare Function CGEventSourceCreate lib "ApplicationServices" (CGEventSourceStateID as UInt32) as ptr		      const kCGEventSourceStatePrivate = -1		      		      //now for the clicking		      //get mouse location		      dim CGMouseEvent as Ptr = CGEventCreate(nil)		      dim mouseLoc as CGPoint = CGEventGetLocation(CGMouseEvent)		      CFRelease(CGMouseEvent)		      		      //create event source		      dim sourceRef as ptr = CGEventSourceCreate(kCGEventSourceStatePrivate)		      		      //press down		      dim clickMouse as ptr = CGEventCreateMouseEvent(sourceRef, kCGEventLeftMouseDown, mouseLoc, 0)		      CGEventPost(tapLocation, clickMouse)		      CFRelease(clickMouse)		      		      //release mouse		      dim releaseMouse as ptr = CGEventCreateMouseEvent(sourceRef, kCGEventLeftMouseUp, mouseLoc, 0)		      CGEventPost(tapLocation, clickMouse)		      CFRelease(releaseMouse)		      		    #endif		  #endif		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Cocoa_SetCursorPosition(newX as Integer, newY as Integer)		  //Code by: Jason K		  // https://forum.xojo.com/12285-move-mouse-cursor-and-click-by-code-for-mac		  // 25 May 2014		  		  #if targetmacos		    #if TargetCocoa		      		      //Structure CGPoint:		      //////////		      //x as single		      //y as single		      //////////		      		      Declare function CGWarpMouseCursorPosition lib "ApplicationServices" (newPoint as CGPoint) as Ptr		      dim pt as CGPoint		      //center mouse in the window		      pt.x = newX		      pt.y = newY		      call CGWarpMouseCursorPosition(pt)		      		    #endif		  #endif		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function GetKeyboardEvent() As String		  Dim CapsLockKey As Boolean = False		  If keyboard.AsyncKeyDown(57) Then CapsLockKey = True		  		  		  For i As Integer = 0 to 126		    If Keyboard.AsyncKeyDown( i ) Then		      If  Keyboard.asyncShiftKey = True Then		        If KeyBoard.KeyName( i ) = "1" Then Return "!"		        If KeyBoard.KeyName( i ) = "2" Then Return "@"		        If KeyBoard.KeyName( i ) = "3" Then Return "#"		        If KeyBoard.KeyName( i ) = "4" Then Return "$"		        If KeyBoard.KeyName( i ) = "5" Then Return "%"		        If KeyBoard.KeyName( i ) = "6" Then Return "^"		        If KeyBoard.KeyName( i ) = "7" Then Return "&"		        If KeyBoard.KeyName( i ) = "8" Then Return "*"		        If KeyBoard.KeyName( i ) = "9" Then Return "("		        If KeyBoard.KeyName( i ) = "0" Then Return ")"		        If KeyBoard.KeyName( i ) = "=" Then Return "+"		        If KeyBoard.KeyName( i ) = "-" Then Return "_"		        If KeyBoard.KeyName( i ) = "]" Then Return "}"		        If KeyBoard.KeyName( i ) = "[" Then Return "{"		        If KeyBoard.KeyName( i ) = "'" Then Return """"		        If KeyBoard.KeyName( i ) = ";" Then Return ":"		        If KeyBoard.KeyName( i ) = "," Then Return "<"		        If KeyBoard.KeyName( i ) = "/" Then Return "?"		        If KeyBoard.KeyName( i ) = "." Then Return ">"		        If KeyBoard.KeyName( i ) = "`" Then Return "~"		        If KeyBoard.KeyName( i ) = "\" Then Return "|"		      ElseIf  Keyboard.asyncShiftKey = False Then		        If Len( KeyBoard.KeyName( i ) ) = 1 Then		          If IsNumeric( KeyBoard.KeyName( i ) ) Then Return KeyBoard.KeyName( i ) '1234567890		          If CapsLockKey = True Then Return UpperCase( KeyBoard.KeyName( i ) ) 'ABCDEFGHIJKLMNOPQRSTUWXYZ`-=[];',./		          If CapsLockKey = False Then Return LowerCase( KeyBoard.KeyName( i ) ) 'abcdefghijklmnopqrstuvwxyz`-=[];',./		        Else		          If KeyBoard.KeyName( i ) = "Enter" Then Return EndOfLine		          If KeyBoard.KeyName( i ) = "Space" Then Return Chr(&h20)		          If CapsLockKey = True Then Return UpperCase( KeyBoard.KeyName( i ) )		          If CapsLockKey = False Then Return LowerCase( KeyBoard.KeyName( i ) )		        End		      End		    End		  Next		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetMenuItemByMenuName(MenuName As String) As LsMenuItem		  DIm i,n As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If BaseMenu(i).MenuName = MenuName Then		        		        return BaseMenu(i)		        		        Exit For i		      End If		    Next		  End If		  		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetMenuItemFromKeyboardShortcut(shortcut As String) As LsMenuItem		  		  		  DIm i,n As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If Uppercase(BaseMenu(i).KeyboardShortcut) = Uppercase(shortcut) Then		        		        return BaseMenu(i)		        Exit For i		      Else		        Dim ci,cn As Integer		        Dim found As Boolean = False		        cn = BaseMenu(i).baseMenu.Count -1		        if cn>-1 Then		          For ci=0 to cn		            If Uppercase(BaseMenu(i).baseMenu.Item(ci).KeyboardShortcut) = Uppercase(shortcut) Then		              Dim xLM As New LsMenuItem(BaseMenu(i).baseMenu.Item(ci).Text,BaseMenu(i).MenuName,BaseMenu(i).uID)		              xLM.parentItem = BaseMenu(i)		              found = True		              return xLM		              Exit For ci		            End If		          Next		          if found then Exit For i		        End If		        		      End If		    Next		  End If		  		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetMenuItemFromXY(x As Integer, Y As Integer) As LsMenuItem		  Dim tP As Picture = New Picture(1,1,32)		  tp.Graphics.TextFont = me.TextFont		  tp.Graphics.TextSize = me.TextSize		  tp.Graphics.TextUnit = FontUnits.Pixel		  		  DIm i,n As Integer		  Dim w,h As Integer		  h = self.height		  Dim offset As Integer = 0		  n = BaseMenu.Ubound		  If n>-1 Then		    		    		    		    For i=0 to n		      		      Dim mW As Integer = basemenu(i).MenuPic.Width		      Dim mSelected As Boolean = False		      Dim hover As Boolean = False		      		      if (y > self.top) and (y<self.top + self.Height) Then		        If (X > (self.left + offset)) and (X< (self.left + offset + mW)) Then		          hover = True		          if (System.MouseDown) and (IsContextualClick = False) Then mSelected = True		          BaseMenu(i).DrawMenuItem(mSelected,hover,mForceRedraw)		          BaseMenu(i).mOffset = offset + mW		          		          return BaseMenu(i)		          		          Exit For i		          		        End If		      End If		      		      offset = offset + mW		      		    Next		    		  End If		  		  		  If ((x>=overflowMX)and(x<=overFlowMX+overFlowMWidth)) and ((y>=overFlowMY)and(y<=overFlowMY+self.height)) Then		    return mOVMenu		  End If		  		  		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub KeyDogAction(sender As Timer)		  //gather current Keyboard Shortcut and raise the depending MenuItem-HitItem-Event		  		  if isActive Then		    		    Dim CMD_Key, CTRL_KEY, ALT_KEY As Boolean = False		    DIM c_KEY, m_KEY, e_KEY As String = ""		    		    		    if keyboard.AsyncCommandKey Then 		      #if targetmacos		        m_KEY = "CMD"		      #elseif TargetWin32		        m_KEY = "CTRL"		      #endif		      		    ENd If		    if keyboard.AsyncControlKey Then CTRL_Key = True		    if keyboard.AsyncAltKey Then ALT_Key = True		    		    c_KEY = GetKeyBoardEvent()		    		    e_KEY = m_KEY + "+" + c_KEY		    		    DIm fItem As LsMenuItem 		    if not (e_KEY="+") Then fITEM= GetMenuItemFromKeyboardShortcut(e_KEY)		    if fItem<>Nil Then		      If fItem.parentItem<>Nil Then		        fITEM.parentItem.Selected = True		        self.Invalidate()		        		        App.DoEvents(100)		        		        fITEM.parentItem.Selected = False		        self.Invalidate()		      End If		      RaiseEvent HitMenuItem(GetMenuItemFromKeyboardShortcut(e_KEY))		    End If		    		  end if		  		  		  'ConsoleLog(e_KEY)		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub K_MouseClickEx(optX As Integer, optY As Integer)		  		  		  #if targetwin32 then		    call remoteControlMBS.winmouseClick optX,optY,true,true		  #elseif targetmachO then		    call remoteControlMBS.MacMouseClick optX,optY, true, true		  #elseif targetlinux then		    'call remoteControlMBS.linuxMouseClick(1,true)		  #else		    'ErrorLog.Append("KERN_MouseClick is not supported with this platform!")		  #endif		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub K_MouseClickOS(x as integer, y as integer)		  #if TargetWin32		    		    Win_MouseClick(x,y,true)		    Win_MouseClick(x,y,true)		    		  #elseif TargetMacOS		    #if TargetCocoa		      'Cocoa_SetCursorPosition(x, y)		      		      Cocoa_LeftClickMouse		      Cocoa_LeftClickMouse		    #endif		  #Endif		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub K_MouseUpEx(optX As Integer, optY As Integer)		  		  		  #if targetwin32 then		    call remoteControlMBS.winmouseClick optX,optY,true,false		  #elseif targetmachO then		    call remoteControlMBS.MacMouseClick optX,optY, true, false		  #elseif targetlinux then		    'call remoteControlMBS.linuxMouseClick(1,false)		  #else		    'ErrorLog.Append("KERN_MouseClickUP is not supported with this platform!")		  #endif		  		  'self.topmost = True		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub MouseDogAction(sender As Timer)		  'App.m_Add_Function_REF(self.title+".MouseDogAction()")		  		  if isActive Then		    		    		    'if (BehaveAsToolBar and (ClickAction = True)) Then return		    		    Dim x,y As Integer		    X = System.MouseX - self.left - self.Window.left		    Y = System.MouseY - self.top - self.Window.top		    		    //HelpTag Toggle to only show, when needed		    if (mX=X) and (mY=Y) Then		      mC = mC + 1 //theperiod counter - timer.period = 150 -> mC must be 14 to fire HelpTag		      self.mHelptag = self.mHelptag		    Else		      mC = 0		    ENd If		    		    mX = X		    mY = Y		    		    if x<>lastX or y<>lastY Then		      		      if (self.window.Focus<>Nil) Then //check wether the window is accessible and topmost (Window with focus)		        		        if selectedMenuItem<>Nil Then		          		          if (selectedMenuItem.isPopUpBox Or selectedMenuItem.isPopUpMenu ) Then return		          		          if selectedMenuItem.MenuName = "overflow_Menu" Then 		            if (System.MouseDown) and (IsContextualClick = False) Then		              selectedMenuItem.DrawMenuItem(false,false,mForceRedraw)		            End If		            return		          End If		          		          if BehaveAsToolBar = True Then return		          		          Dim tMI As LsMenuItem = GetMenuItemFromXY(X,Y)		          if tMI <> Nil Then		            		            if not ( tMI.uID = selectedMenuItem.uID ) Then		              		              if useMBS_MouseFunctions Then		                K_MouseClickEx(System.MouseX,System.MouseY)		                K_MouseUpEx(System.MouseX,System.MouseY)		              Else		                #if TargetWin32		                  		                  Win_MouseClick(x,y,true)		                  Win_MouseClick(x,y,false)		                  		                #elseif TargetMacOS		                  #if TargetCocoa		                    'Cocoa_SetCursorPosition(x, y)		                    		                    Cocoa_LeftClickMouse		                    		                  #endif		                #Endif		              End If		              		              selectedMenuItem = Nil		              selectedMenuItem = tMI		              'ConsoleLog("Open: " + tMI.MenuName)		              if useMBS_MouseFunctions Then		                K_MouseClickEx(System.MouseX,System.MouseY)		                K_MouseUpEx(System.MouseX,System.MouseY)		              Else		                #if TargetWin32		                  		                  Win_MouseClick(x,y,true)		                  Win_MouseClick(x,y,false)		                  		                #elseif TargetMacOS		                  #if TargetCocoa		                    'Cocoa_SetCursorPosition(x, y)		                    		                    Cocoa_LeftClickMouse		                    'Cocoa_LeftClickMouse		                  #endif		                #Endif		              End If		              'OpenHitMenu(selectedMenuItem)		              		            End If		          End If		          		        Else		          		          		        End If		        		      End If		      		    end if		    		    lastX = X		    lastY = Y		    		    		    'app.m_Add_ErrorLog("LsMenuBar:MouseDogAction")		    		  end if		  'RaiseEvent ConsoleLog(str(x) + ":" + str(y))		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub OpenContextMenu()		  'isActive = False		  		  		  Dim hitItem As MenuItem = contextMenu.PopUp()		  if hitItem<>Nil Then		    select case hitItem.Text		      		    case "Symbolleiste anpassen"		      		      		      changeMenuWin.Show()		      changeMenuWin.parentBaseMenu = BaseMenu		      changeMenuWin.Init()		      		    End Select		  ENd If		  		  'isActive = True		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub OpenHitMenu(menu As LsMenuItem,offset As Integer = -1)		  		  'isActive = False		  		  if menu = nil or menu.basemenu = Nil Then return		  		  ClickAction = True		  'if BehaveAsToolBar Then		  'MouseDog.Enabled = False		  'KeyDog.Enabled = False		  'End If		  		  Dim popMenu As Boolean = False		  Dim xOffset As Integer = offset		  Dim yMenuOffest As Integer = 0		  if xOffset = -1 Then xOffset = menu.mOffset		  		  if menu.isToolBarItem Then		    if menu.isPopUpBox Or menu.isPopUpMenu Then		      if menu.isFirstInGroup Then		        xOffset = xOffset + 8		      Elseif menu.isLastInGroup Then 		        xOffset = xOffset + 4		      ElseIf menu.isInsideGroup Then		        xOffset = xOffset + 4		      Else		        xOffset = xOffset + 8		      End If		      		      yMenuOffest = 5		      		      Dim mi,mn As Integer		      mn = menu.baseMenu.Count - 1		      if mn>-1 Then		        For mi=0 to mn		          if menu.baseMenu.Item(mi).Text = menu.Text Then 		            menu.baseMenu.Item(mi).Checked = True		          Else		            menu.baseMenu.Item(mi).Checked = False		          End If		          		        Next		      End If		      		      popMenu = True		      		    Elseif menu.MenuName = "overflow_Menu" Then		      xOffset = xOffset + 4		      		      popmenu = True		    End If		  End If		  		  'if popMenu Then		  		  selectedMenuItem = menu		  Dim choice As MenuItem = menu.basemenu.PopUp(me.window.left+xoffset,me.window.top+me.top+me.height-yMenuOffest)		  		  if choice is nil then		    		    'menu.DrawMenuItem(false,false)		    'selectedMenuItem.DrawMenuItem(false,false)		    		    menu = nil		    'selectedMenuItem = Nil		    		    self.Invalidate()		    		    'MouseDog.Enabled = True		    'KeyDog.Enabled = True		    ClickAction = False		    'isActive = True		    exit		    		  Else		    		    if menu.isToolBarItem Then		      if menu.isPopUpBox Then		        SetMenuItemText(menu.MenuName,choice.Text)		      End If		    End If		    		    if choice.tag<>Nil Then		      if choice.tag isa folderitem then		        RaiseEvent HitMenuItemFolderItem(choice.text,choice.tag)		      else		        RaiseEvent HitMenuItem(GetMenuItemByMenuName(str(choice.tag)))		      end if		    Else		      RaiseEvent PopUpMenu(menu,choice)		    End If		  End If		  		  //		  // [BUG]		  //		  // Sometimes the Menu just freezes the whole app_main_thread and prevents the user to do anything?		  // might have to investigate further		  //		  		  		  'End If		  		  selectedMenuItem = Nil		  		  'MouseDog.Enabled = True		  'KeyDog.Enabled = True		  ClickAction = False		  		  me.Invalidate()		  		  'isActive = True		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Pause()		  If KeyDog<>Nil Then		    KeyDog.Enabled = False		    		  End If		  		  If MouseDog<>Nil Then		    MouseDog.Enabled = False		    		  End If		  		  isActive = False		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Redraw(byVal g As Graphics)		  Dim tP As Picture = New Picture(1,1,32)		  tp.Graphics.TextFont = TextFont		  tp.Graphics.TextSize = TextSize		  tp.Graphics.TextUnit = FontUnits.Pixel		  		  //Fill the MenuBar background		  g.ForeColor = FillColor		  g.FillRect(0,0,self.width,self.height)		  		  'Dim ovI() As LsMenuItem		  'overflowMenu = ovI		  Redim overflowMenu(-1)		  		  Dim ovItem As New LsMenuItem()		  ovItem.Constructor("...","overflow_Menu","TB_overflow_Menu")		  'ovItem.Text = "..."		  'ovItem.MenuName = "overflow_Menu"		  'ovItem.uID = "TB_overflow_Menu"		  ovItem.MenuBarHeight = me.height		  ovItem.TextColor = TextColor		  ovItem.TextSize = TextSize		  ovItem.TextFont = TextFont		  ovItem.TextHighlightColor = TextHighlightColor		  ovItem.ItemHighlightColor = ItemHighlightColor		  ovItem.FillColor = FillColor		  ovItem.ItemHoverColor = ItemHoverColor		  ovItem.ToolBarBorderColor = ToolBarItemBorderColor		  ovItem.isToolBarItem = True		  ovItem.showCaption = True		  ovItem.DrawMenuItem(false,false,mForceRedraw)		  		  		  		  		  DIm i,n As Integer		  Dim w,h As Integer		  h = self.height		  Dim offset As Integer = 0		  		  if BehaveAsToolBar Then offset = 4		  		  n = BaseMenu.Ubound		  If n>-1 Then		    		    For i=0 to n		      		      Dim mSelected As Boolean = False		      Dim mHover As Boolean = False		      		      If (System.MouseX >= (self.window.left + self.left + offset)) and (System.MouseX<= (self.window.left + self.left + offset + BaseMenu(i).MenuPic.Width)) Then		        If (System.MouseY >= (self.window.Top + self.Top)) and (System.MouseY<= (self.window.Top + self.Top + self.Height)) Then 		          mHover = True		          if ((System.MouseDown) and (IsContextualClick = False)) Then mSelected = True		        End If		      End If		      		      if selectedMenuItem<>Nil Then		        if selectedMenuItem.MenuName = BaseMenu(i).MenuName Then mSelected = True		      End If		      		      'if mHover = True Then		      'Dim mx As Integer = System.MouseX		      'Dim m_x As Integer = self.window.left + self.left + offset		      'End If		      		      //		      //Check if the Item belongs to a group		      Dim xGroupID As String = BaseMenu(i).GroupID		      Dim lItem,tItem As String		      If (i-1)>-1 Then		        lItem = BaseMenu(i-1).GroupID		      ENd If		      If (i+1)<=n Then		        tItem = BaseMenu(i+1).GroupID		      ENd If		      If (not (xGroupID="")) Then		        if not (lItem = xGroupID) Then 		          BaseMenu(i).isFirstInGroup = True		        Else		          BaseMenu(i).isFirstInGroup = False		        End If		        If not (tItem = xGroupID) Then 		          BaseMenu(i).isLastInGroup = True		        Else		          BaseMenu(i).isLastInGroup = False		        End If		        If (BaseMenu(i).isFirstInGroup = False) and (BaseMenu(i).isLastInGroup = False) Then 		          BaseMenu(i).isInsideGroup = True		        Else		          BaseMenu(i).isInsideGroup = False		        End If		      End If		      //###########################################		      		      'BaseMenu(i).Icon = BaseMenu(i).ToolbarIcon		      		      If BaseMenu(i).Selected Then mSelected = True		      		      if not MouseInside then 		        mHover = False		      End If		      		      BaseMenu(i).DrawMenuItem(mSelected,mHover,mForceRedraw)		      		      		      Dim xMenuP As Picture = baseMenu(i).MenuPic		      		      //Check if the Menu appers on screen or should move to overFlow		      if BehaveAsToolBar Then		        If (offset + xMenuP.Width + ovItem.MenuPic.Width + 15) > self.width Then		          BaseMenu(i).isVisible = False		          overFlowMenu.Append BaseMenu(i)		        Else		          //is not in overflow -> Draw Item		          BaseMenu(i).isVisible = True		          g.DrawPicture(xMenuP,offset,0)		        End If		      ELse		        BaseMenu(i).isVisible = True		        g.DrawPicture(xMenuP,offset,0)		      End If		      		      if mHover Then		        mHoverMenu = BaseMenu(i)		        'if mHoverMenu.isVisible Then self.mHelptag = mHoverMenu.HelpTag		      End If		      		      offset = offset + xMenuP.Width		      		    Next		    		  End If		  		  //Draw the overflow Menu if ToolBar		  if BehaveAsToolBar Then		    Dim hasVisibleOverflow As Boolean = False		    if selectedMenuItem<>Nil Then		      if selectedMenuItem.MenuName="overflow_Menu" Then 		        hasVisibleOverflow = True		        GOTO hasOverflow		      End If		    End If		    		    Dim oi,on As Integer		    mOVMenu = New LsMenuItem("...","overflow_Menu","TB_overflow_Menu")		    		    on = overFlowMenu.Ubound		    if on>-1 Then		      Dim tix As MenuItem		      For oi=0 to on 		        		        tix = New MenuItem(overFlowMenu(oi))		        tix.icon = overflowMenu(oi).ToolbarIcon		        tix.Tag = overflowMenu(oi).MenuName		        'overflowMenu(oi).Icon = 		        		        DIm ovii,ovn As Integer		        ovn = overflowMenu(oi).baseMenu.Count - 1		        if ovn>-1 Then		          For ovii=0 to ovn		            tix.Append(overflowMenu(oi).baseMenu.Item(ovii).Clone)		          Next		        ENd If		        		        mOVMenu.baseMenu.Append(tix)		        		        if (overFlowMenu(oi).isLastInGroup) and (oi<on) Then mOVMenu.baseMenu.Append(New MenuItem(MenuItem.TextSeparator))		        		      Next		      		      'Dim mSelected As Boolean = False		      'Dim mHover As Boolean = False		      '		      'If (System.MouseX >= (self.window.left + self.left + offset)) and (System.MouseX<= (self.window.left + self.left + offset + BaseMenu(i).MenuPic.Width)) Then		      'If (System.MouseY >= (self.window.Top + self.Top)) and (System.MouseY<= (self.window.Top + self.Top + self.Height)) Then		      'mHover = True		      'if ((System.MouseDown) and (IsContextualClick = False)) Then mSelected = True		      'End If		      'End If		      		      'ovItem.Text = "..."		      'ovItem.MenuName = "overflow_Menu"		      'ovItem.uID = "TB_overflow_Menu"		      		      ovItem.DrawMenuItem(false,false,mForceRedraw)		      		      Dim xsel,xhov As Boolean = False		      		      If (System.MouseX >= (self.window.left + self.left + self.width - ovItem.MenuPic.Width - 10)) and (System.MouseX<= (self.window.left + self.left + self.width)) Then		        If (System.MouseY >= (self.window.Top + self.Top)) and (System.MouseY<= (self.window.Top + self.Top + self.Height)) Then		          xhov = true		          if (System.MouseDown) and (IsContextualClick = False) Then xsel = True		        ENd If		      End If		      		      hasOverflow:		      if hasVisibleOverflow Then 		        if (System.MouseDown=False) and (IsContextualClick = False) Then		          xsel = False		        Else		          If (System.MouseY >= (self.window.Top + self.Top)) and (System.MouseY<= (self.window.Top + self.Top + self.Height)) Then 		            xsel = True		          End If		        End If		      End If		      ovItem.MenuBarHeight = self.height		      ovItem.Init_Draw()		      ovItem.DrawMenuItem(xsel,xhov,mForceRedraw)		      		      Dim xMenuP As Picture = ovItem.MenuPic		      		      if offset>self.width - xMenuP.Width - 10 Then 		        g.DrawPicture(xMenuP,self.width - xMenuP.Width - 10,0)		        overflowMX = self.width - xMenuP.Width - 10		        overflowMY = 0		        overFlowMWidth = xMenuP.Width		        		        'mOVMenu = LsMenuItem(ovItem.Clone())		        		        'mOVMenu.baseMenu = ovItem.baseMenu.Clone		        mOVMenu.MenuBarHeight = me.height		        mOVMenu.TextColor = TextColor		        mOVMenu.TextSize = TextSize		        mOVMenu.TextFont = TextFont		        mOVMenu.TextHighlightColor = TextHighlightColor		        mOVMenu.ItemHighlightColor = ItemHighlightColor		        mOVMenu.FillColor = FillColor		        mOVMenu.ItemHoverColor = ItemHoverColor		        mOVMenu.ToolBarBorderColor = ToolBarItemBorderColor		        mOVMenu.isToolBarItem = True		        mOVMenu.showCaption = True		        mOVMenu.DrawMenuItem(false,false,mForceRedraw)		        		      Else		        mOVMenu.baseMenu = nil		      End If		      		    End If		  ENd If		  		  		  mForceRedraw = False		  		  		  drawBorder:		  		  if hasBorder Then		    		    //Define BorderPenWidth		    g.PenWidth = BorderWidth		    g.PenHeight = BorderWidth		    		    //Draw TopLeftBorder		    g.ForeColor = TopLeftBorderColor		    g.DrawLine(0,0,self.width,0)		    g.DrawLine(0,0,0,self.Height)		    		    //Draw BottomRightBorder		    g.ForeColor = BottomRightColor		    g.DrawLine(0,self.height-BorderWidth,self.width,self.height-BorderWidth)		    g.DrawLine(self.width-BorderWidth,self.height-BorderWidth,self.width-BorderWidth,0)		    		  End If		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Resume()		  isActive = True		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetMenuItemIcon(MenuName As String, newIcon As Picture)		  DIm i,n As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If BaseMenu(i).MenuName = MenuName Then		        		        BaseMenu(i).ToolbarIcon = newIcon		        		        mForceRedraw = True		        		        Exit For i		      End If		    Next		  End If		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetMenuItemProperty(MenuName As String, PropertyName As String, PropertyValue As Variant)		  DIm i,n As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If BaseMenu(i).MenuName = MenuName Then		        		        		        Select Case PropertyName		        case "isEnabled"		          BaseMenu(i).isEnabled = PropertyValue		        case "Text"		          BaseMenu(i).Text = PropertyValue		        case "MenuName"		          BaseMenu(i).MenuName = PropertyValue		        case "Icon"		          BaseMenu(i).ToolBarIcon = PropertyValue		        End Select		        		        'BaseMenu(i).Text = newText		        		        mForceRedraw = True		        		        self.refresh()		        		        Exit For i		      End If		    Next		  End If		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetMenuItemText(MenuName As String, newText As String)		  DIm i,n As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If BaseMenu(i).MenuName = MenuName Then		        		        BaseMenu(i).Text = newText		        		        mForceRedraw = True		        		        Exit For i		      End If		    Next		  End If		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetSubMenuItemProperty(BaseMenuName As String, SubMenuName As String, PropertyName As String, PropertyValue As Variant)		  DIm i,n As Integer		  Dim c,j As Integer		  n = BaseMenu.Ubound		  If n>-1 Then		    For i=0 to n		      If BaseMenu(i).MenuName = BaseMenuName Then		        		        j = BaseMenu(i).BaseMenu.Count - 1		        		        if j>-1 Then		          For c=0 to j		            if BaseMenu(i).BaseMenu.Item(c).Text = SubMenuName Then		              		              //Set MenuName is not allowed in Submenus		              		              Select Case PropertyName		              case "isEnabled"		                BaseMenu(i).BaseMenu.Item(c).Enabled = PropertyValue		              case "Text"		                BaseMenu(i).BaseMenu.Item(c).Text = PropertyValue		              case "Icon"		                BaseMenu(i).BaseMenu.Item(c).Icon = PropertyValue		              End Select		              		              'BaseMenu(i).Text = newText		              		              mForceRedraw = True		              		              self.refresh()		              		              Exit For i		            End If		          Next		        End If		      End If		    Next		  End If		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Win_MouseClick(x As Integer, y As Integer,click as boolean)		  // Windows code from: Michel B - XOJO Forum		  // https://forum.xojo.com/12259-move-mouse-position-click-by-code-windows		  // 25 May 2014		  		  #if TargetWin32		    if click = true then		      Declare sub mouse_event Lib "user32" (ByVal dwFlags As Integer, ByVal dx As Integer, ByVal dy As Integer, ByVal dwData As Integer, ByVal dwExtraInfo As Integer)		      		      const MOUSEEVENTF_ABSOLUTE = &h8000		      const MOUSEEVENTF_LEFTDOWN = &h2		      const MOUSEEVENTF_LEFTUP = &h4		      const MOUSEEVENTF_MIDDLEDOWN = &h20		      const MOUSEEVENTF_MIDDLEUP = &h40		      const MOUSEEVENTF_MOVE = &h1		      const MOUSEEVENTF_RIGHTDOWN = &h8		      const MOUSEEVENTF_RIGHTUP = &h10		      const MOUSEEVENTF_WHEEL = &h800		      const MOUSEEVENTF_XDOWN = &h80		      const MOUSEEVENTF_XUP = &h100		      const MOUSEEVENTF_HWHEEL = &h1000		      		      Dim cur_x As integer		      Dim cur_y As integer		      Dim dest_x As integer		      Dim dest_y As integer		      Dim dx As integer		      Dim dy As integer		      		      dest_x = (65535/screen(0).width)*x		      dest_y = (65535/screen(0).height)*y		      		      call mouse_event(MOUSEEVENTF_ABSOLUTE+MOUSEEVENTF_MOVE+MOUSEEVENTF_LEFTDOWN+MOUSEEVENTF_LEFTUP,dest_x, dest_y, 0, 0)		    else		      Declare Function SetCursorPos Lib "user32" (ByVal x As Integer, ByVal y As Integer) As Integer		      //==========================================		      // Set cursor position to top left of screen		      //==========================================		      call SetCursorPos(x,y)		    end if		  #EndIf		End Sub	#tag EndMethod	#tag Hook, Flags = &h0		Event ConsoleLog(cmd As String)	#tag EndHook	#tag Hook, Flags = &h0		Event HitMenuItem(menu As LsMenuItem)	#tag EndHook	#tag Hook, Flags = &h0		Event HitMenuItemFolderItem(menuName As String, fi As FolderItem)	#tag EndHook	#tag Hook, Flags = &h0		Event PopUpMenu(baseMenu As LsMenuItem, selectedMenu As MenuItem)	#tag EndHook	#tag Note, Name = About				LsMenuBar & LsMenuItem				This is a replacement for the built in MenuBars and ToolBars.		The classes are able to behave like a MenuBar or a ToolBar with grouping and an overflowmenu.						--- --- --- --- --- --- --- ---				Title:    LsMenuBar		Version:  0.1				Author:   Patric Lee Atrott		Web:      www.atrott.net								### ### ### ### ### ### ### ###		Notes:		--- --- --- --- --- --- --- ---				LsMenuBar & LsMenuItem and pending classes, structures, etc.		are not finished yet and can be very buggy from time to time.						This class is able to use MBS Plugins.		It is highly recommended to use MBS Plugins.												### ### ### ### ### ### ### ###		Contributors:		--- --- --- --- --- --- --- ---				The XOJO Community				  // Cocoa_Mouseclick Code by: Jason K		  // https://forum.xojo.com/12285-move-mouse-cursor-and-click-by-code-for-mac		  // 25 May 2014				  // Windows_Mouseclick Code from: Michel B - XOJO Forum		  // https://forum.xojo.com/12259-move-mouse-position-click-by-code-windows		  // 25 May 2014				Icons by Yusuke Kamiyamane.		Fugue Icons		  (C) 2013 Yusuke Kamiyamane. All rights reserved.		  These icons are licensed under a Creative Commons		  Attribution 3.0 License.		  <http://creativecommons.org/licenses/by/3.0/>		  If you can't or don't want to provide attribution, please		  purchase a royalty-free license.		  <http://p.yusukekamiyamane.com/>								### ### ### ### ### ### ### ###		License:		--- --- --- --- --- --- --- ---				CC BY SA 4.0						http://creativecommons.org/licenses/by-sa/4.0/		http://creativecommons.org/licenses/by-sa/4.0/legalcode				You are free to:				    Share — copy and redistribute the material in any medium or format		    Adapt — remix, transform, and build upon the material		    for any purpose, even commercially.				    The licensor cannot revoke these freedoms as long as you follow the license terms.				Under the following terms:				    Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.				    ShareAlike — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.				    No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.				Notices:				    You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.		    No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.			#tag EndNote	#tag Property, Flags = &h0		BaseMenu() As LsMenuItem	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mBehaveAsToolBar			End Get		#tag EndGetter		#tag Setter			Set			  mBehaveAsToolBar = value			  			  if value then			    if MouseDog<>Nil then MouseDog.Period = 50			  else			    if MouseDog<>Nil then MouseDog.Period = 150			  end if			End Set		#tag EndSetter		BehaveAsToolBar As Boolean	#tag EndComputedProperty	#tag Property, Flags = &h0		BorderWidth As Integer	#tag EndProperty	#tag Property, Flags = &h0		BottomRightColor As Color	#tag EndProperty	#tag Property, Flags = &h0		ClickAction As Boolean = False	#tag EndProperty	#tag Property, Flags = &h0		contextMenu As MenuItem	#tag EndProperty	#tag Property, Flags = &h0		FillColor As Color	#tag EndProperty	#tag Property, Flags = &h0		hasBorder As Boolean	#tag EndProperty	#tag Property, Flags = &h0		hasHelpTag As Boolean	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return misActive			End Get		#tag EndGetter		#tag Setter			Set			  misActive = value			  			  if value then			    MouseDog.Enabled = true			    MouseDog.period = 250			    MouseDog.Mode = Timer.ModeMultiple			    MouseDog.Reset()			    'keydog.Enabled = true			    'KeyDog.period = 150			    'KeyDog.Mode = Timer.ModeMultiple			    'keydog.Reset()			    			    mForceRedraw = True			    			    self.refresh()			  Else			    			  end if			End Set		#tag EndSetter		isActive As Boolean	#tag EndComputedProperty	#tag Property, Flags = &h0		ItemHighlightColor As Color	#tag EndProperty	#tag Property, Flags = &h0		ItemHoverColor As Color	#tag EndProperty	#tag Property, Flags = &h0		KeyDog As Timer	#tag EndProperty	#tag Property, Flags = &h1		Protected lastBufPic As Picture	#tag EndProperty	#tag Property, Flags = &h0		lastX As Integer	#tag EndProperty	#tag Property, Flags = &h0		lastY As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private mBehaveAsToolBar As Boolean	#tag EndProperty	#tag Property, Flags = &h0		mC As Integer	#tag EndProperty	#tag Property, Flags = &h0		mForceRedraw As Boolean = False	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mmHelpTag			End Get		#tag EndGetter		#tag Setter			Set			  			  			  //HELPTAGS are switched off because of performance issues			  'if value = "[#KILL]" Then			  'myLsHelpTag.CloseTag()			  'End If			  'if isActive Then			  'if (value<>mmHelpTag) Or (value="" or value=" ") Then			  'myLsHelpTag.CloseTag			  'End If			  'if mC = 10 Then			  '			  'if hasHelpTag Then			  '			  'if value = "[#KILL]" Then			  'myLsHelpTag.CloseTag()			  'Else			  'if not (value = "" or value = " ") Then 			  'me.SetFocus()			  'if not myLsHelpTag.Visisble Then myLsHelpTag.CreateHelpTag(value,system.MouseX,self.TrueWindow.top + self.top + self.Height - 4)			  '			  'End If			  'ENd If			  'End If			  'End If			  '			  'mmHelpTag = value			  'End If			  			  			  			  			  			  			  			  			  			  'if (mHWin<>Nil)THen			  'If (value<>mHWin.Caption) Then			  'mHWin.Close()			  'mHWin = New KLEX_HelpTag			  'End If			  'End If			  'if mHWin = Nil Then mHWin = New KLEX_HelpTag			  ''mHWin = New KLEX_HelpTag			  ''mHWin.Show()			  'mHWin.Caption = value			  'mHWin.Left = System.MouseX			  'mHWin.Top = self.TrueWindow.top + self.top + self.Height - 4			  'mHWin.ResizeWin()			  'mHWin.Show()			End Set		#tag EndSetter		mHelpTag As String	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mmHoverMenu			End Get		#tag EndGetter		#tag Setter			Set			  if value<>Nil Then			    'if mmHoverMenu.Text<>value.Text Then			    if value.isVisible Then self.mHelptag = value.HelpTag			    			    'End If			  ENd If			  			  mmHoverMenu = value			End Set		#tag EndSetter		mHoverMenu As LsMenuItem	#tag EndComputedProperty	#tag Property, Flags = &h21		Private misActive As Boolean	#tag EndProperty	#tag Property, Flags = &h21		Private mmHelpTag As String	#tag EndProperty	#tag Property, Flags = &h21		Private mmHoverMenu As LsMenuItem	#tag EndProperty	#tag Property, Flags = &h21		Private mMouseInside As Boolean = False	#tag EndProperty	#tag Property, Flags = &h0		MouseDog As Timer	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mMouseInside			End Get		#tag EndGetter		#tag Setter			Set			  mMouseInside = value			  			  'if not value Then self.mHelptag = "[#KILL]"			  			  			  if MouseDog<>Nil Then 			    			    If value Then 			      MouseDog.Enabled = true			      MouseDog.Mode = 2			      MouseDog.Reset()			      'isActive = True			    Else			      MouseDog.Enabled = False			      MouseDog.Mode = 0			      'isActive = False			    End If			  End If			  'MouseDog.Reset()			  			  			  if not value then mHoverMenu = Nil			End Set		#tag EndSetter		MouseInside As Boolean	#tag EndComputedProperty	#tag Property, Flags = &h0		MouseX As Integer	#tag EndProperty	#tag Property, Flags = &h0		MouseY As Integer	#tag EndProperty	#tag Property, Flags = &h0		mOVMenu As LsMenuItem	#tag EndProperty	#tag Property, Flags = &h21		Private mX As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private mY As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected overflowMenu() As LsMenuItem	#tag EndProperty	#tag Property, Flags = &h1		Protected overFlowMWidth As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected overFlowMX As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected overFlowMY As Integer	#tag EndProperty	#tag Property, Flags = &h0		selectedMenuItem As LsMenuItem	#tag EndProperty	#tag Property, Flags = &h0		TextColor As Color	#tag EndProperty	#tag Property, Flags = &h0		TextFont As String	#tag EndProperty	#tag Property, Flags = &h0		TextHighlightColor As Color	#tag EndProperty	#tag Property, Flags = &h0		TextSize As Integer	#tag EndProperty	#tag Property, Flags = &h0		Title As String	#tag EndProperty	#tag Property, Flags = &h0		ToolBarItemBorderColor As Color	#tag EndProperty	#tag Property, Flags = &h0		TopLeftBorderColor As Color	#tag EndProperty	#tag Property, Flags = &h1		Protected useMBS_MouseFunctions As Boolean	#tag EndProperty	#tag Constant, Name = kModuleVersion, Type = Double, Dynamic = False, Default = \"1", Scope = Private	#tag EndConstant	#tag Structure, Name = CGPoint, Flags = &h0		X As Single		Y As Single	#tag EndStructure	#tag ViewBehavior		#tag ViewProperty			Name="AcceptFocus"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="AcceptTabs"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="AutoDeactivate"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Backdrop"			Visible=true			Group="Appearance"			Type="Picture"			EditorType="Picture"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="BehaveAsToolBar"			Visible=true			Group="General"			InitialValue="False"			Type="Boolean"			EditorType="Enum"			#tag EnumValues				"False - False"				"True - True"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="BorderWidth"			Visible=true			Group="Style"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="BottomRightColor"			Visible=true			Group="Style"			InitialValue="&cC8C8C8"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="ClickAction"			Group="Behavior"			InitialValue="False"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="DoubleBuffer"			Visible=true			Group="Behavior"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Enabled"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="EraseBackground"			Visible=true			Group="Behavior"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="FillColor"			Visible=true			Group="Style"			InitialValue="&cF2F2F2"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="hasBorder"			Visible=true			Group="Style"			InitialValue="True"			Type="Boolean"			EditorType="Enum"			#tag EnumValues				"True - True"				"False - False"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="hasHelpTag"			Group="Behavior"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Height"			Visible=true			Group="Position"			InitialValue="100"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="HelpTag"			Visible=true			Group="Appearance"			Type="String"			EditorType="MultiLineEditor"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="InitialParent"			Group="Anfangszustand"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="isActive"			Group="Behavior"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="ItemHighlightColor"			Visible=true			Group="Text Style"			InitialValue="&c1871BF"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="ItemHoverColor"			Visible=true			Group="Text Style"			InitialValue="&c000000"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="lastX"			Group="Behavior"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="lastY"			Group="Behavior"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockBottom"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockLeft"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockRight"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockTop"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="mC"			Group="Behavior"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="mForceRedraw"			Group="Behavior"			InitialValue="False"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="mHelpTag"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="MouseInside"			Group="Behavior"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="MouseX"			Group="Behavior"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="MouseY"			Group="Behavior"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TabIndex"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TabPanelIndex"			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TabStop"			Visible=true			Group="Position"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TextColor"			Visible=true			Group="Text Style"			InitialValue="&c000000"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="TextFont"			Visible=true			Group="Text Style"			InitialValue="Calibri"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="TextHighlightColor"			Visible=true			Group="Text Style"			InitialValue="&cFFFFFF"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="TextSize"			Visible=true			Group="Text Style"			InitialValue="15"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Title"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="ToolBarItemBorderColor"			Visible=true			Group="General"			InitialValue="&cC8C8C8"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TopLeftBorderColor"			Visible=true			Group="Style"			InitialValue="&cC8C8C8"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="UseFocusRing"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Visible"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Width"			Visible=true			Group="Position"			InitialValue="100"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass